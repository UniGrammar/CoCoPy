#-------------------------------------------------------------------------
#__class__.py -- The parser generation routines.
#Compiler Generator Coco/R,
#Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
#extended by M. Loeberbauer & A. Woess, Univ. of Linz
#ported from Java to Python by Ronald Longo
#
#This program is free software; you can redistribute it and/or modify it
#under the terms of the GNU General Public License as published by the
#Free Software Foundation; either version 2, or (at your option) any
#later version.
#
#This program is distributed in the hope that it will be useful, but
#WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
#for more details.
#
#You should have received a copy of the GNU General Public License along
#with this program; if not, write to the Free Software Foundation, Inc.,
#59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#As an exception, it is allowed to write an extension of Coco/R that is
#used as a plugin in non-free software.
#
#If not otherwise stated, any source code generated by Coco/R (other than
#Coco/R itself) does not fall under the GNU General Public License.
#-------------------------------------------------------------------------*/
from typing import Optional, Set
import copy
import os
from pathlib import Path
import io


from .Errors import Errors
from .Trace import Trace
from .Core import Node, DFA, Symbol, Tab, INDENT
from .CodeGenerator import CodeGenerator


class MyLoopBreak(Exception):
	pass


class ParserGen(object):
	maxTerm = 3  # sets of size < maxTerm are enumerated
	ls = "\n"

	tErr = 0  # error codes
	altErr = 1
	syncErr = 2

	usingPos = None  # usingPos: Position   "using" definitions from the attributed grammar

	errorNr = 0  # highest parser error number
	curSy = None  # symbol whose production is currently generated
	err = None  # generated parser error messages
	srcName = ""  # name of attributed grammar file
	srcDir = ""  # directory of attributed grammar file
	symSet = []

	codeGen = CodeGenerator()

	@staticmethod
	def Overlaps(s1, s2):
		assert isinstance(s1, set)
		assert isinstance(s2, set)
		ln = len(s1)
		for i in range(0, ln):
			if (i in s1) and (i in s2):
				return True
		return False

	def GenErrorMsg(self, errTyp: int, sym: Symbol) -> None:
		assert isinstance(errTyp, int)
		assert isinstance(sym, Symbol)
		self.errorNr += 1
		self.err.write(self.ls + INDENT * 2 + str(self.errorNr) + ' : "')
		if errTyp == self.tErr:
			if sym.name[0] == '"':
				self.err.write(str(DFA.Escape(sym.name)) + " expected")
			else:
				self.err.write(str(sym.name) + " expected")
		elif errTyp == self.altErr:
			self.err.write("invalid " + str(sym.name))
		elif errTyp == self.syncErr:
			self.err.write("this symbol not expected in " + str(sym.name))
		self.err.write('",')

	def NewCondSet(self, s: Set[int]) -> int:
		assert isinstance(s, set)
		for i in range(1, len(self.symSet)):
			# skip symSet[0] (reserved for union of SYNC sets)
			if s == self.symSet[i]:  # s.equals( self.symSet[i] ):
				return i
		self.symSet.append(copy.copy(s))
		return len(self.symSet) - 1

	def GenCond(self, s: Set[int], p: Node) -> None:
		assert isinstance(s, set)
		assert isinstance(p, Node)
		if p.typ == Node.rslv:
			self.codeGen.CopySourcePart(p.pos, 0)
		else:
			n = len(s)
			if n == 0:
				self.codeGen.write("False")  # should never happen
			elif n <= self.maxTerm:
				for i in range(0, len(Symbol.terminals)):
					sym = Symbol.terminals[i]
					assert isinstance(sym, Symbol)
					if sym.n in s:
						self.codeGen.write("self.la.kind == ")
						self.PrintTermName(sym)
						n -= 1
						if n > 0:
							self.codeGen.write(" or ")
			else:
				self.codeGen.write("self.StartOf(" + str(self.NewCondSet(s)) + ")")

	def GenCode(self, p: Optional[Node], indent: int, isChecked: Set[int]) -> None:
		# assert isinstance( p, Node )
		assert isinstance(indent, int)
		assert isinstance(isChecked, set)
		while p is not None:
			if p.typ == Node.nt:  # Non-Terminals
				self.codeGen.Indent(indent)
				if p.retVar is not None:
					self.codeGen.write(p.retVar + " = ")
				self.codeGen.write("self." + p.sym.name + "(")
				self.codeGen.CopySourcePart(p.pos, 0)
				self.codeGen.write(")\n")
			elif p.typ == Node.t:  # Terminals
				self.codeGen.Indent(indent)
				if p.sym.n in isChecked:
					self.codeGen.write("self.Get( )\n")
				else:
					self.codeGen.write("self.Expect(")
					self.PrintTermName(p.sym)
					self.codeGen.write(")\n")
			elif p.typ == Node.wt:
				self.codeGen.Indent(indent)
				s1 = Tab.Expected(p.next, self.curSy)
				s1 |= Tab.allSyncSets
				self.codeGen.write("self.ExpectWeak(")
				self.PrintTermName(p.sym)
				self.codeGen.write(", " + str(self.NewCondSet(s1)) + ")\n")
			elif p.typ == Node.any:
				self.codeGen.Indent(indent)
				self.codeGen.write("self.Get()\n")
			elif p.typ == Node.eps:
				self.codeGen.Indent(indent)
				self.codeGen.write("pass\n")
			elif p.typ == Node.rslv:
				# self.codeGen.Indent( indent )
				# self.codeGen.write( 'pass\n' )
				pass  # Nothing to do
			elif p.typ == Node.sem:
				self.codeGen.CopySourcePart(p.pos, indent)
			elif p.typ == Node.sync:
				self.codeGen.Indent(indent)
				self.GenErrorMsg(self.syncErr, self.curSy)
				s1 = copy.copy(p.set)
				self.codeGen.write("while not (")
				self.GenCond(s1, p)
				self.codeGen.write("):\n")
				self.codeGen.Indent(indent + 1)
				self.codeGen.write("self.SynErr(" + str(self.errorNr) + ")\n")
				self.codeGen.Indent(indent + 1)
				self.codeGen.write("self.Get()\n")
			elif p.typ == Node.alt:
				s1 = Tab.First(p)
				p2 = p
				equal = s1 == isChecked
				while p2 is not None:
					s1 = Tab.Expected(p2.sub, self.curSy)
					self.codeGen.Indent(indent)
					if p2 == p:
						self.codeGen.write("if ")
						self.GenCond(s1, p2.sub)
						self.codeGen.write(":\n")
					elif p2.down is None and equal:
						self.codeGen.write("else:\n")
					else:
						self.codeGen.write("elif ")
						self.GenCond(s1, p2.sub)
						self.codeGen.write(":\n")
					s1 |= isChecked
					self.GenCode(p2.sub, indent + 1, s1)
					p2 = p2.down
				if not equal:
					self.codeGen.Indent(indent)
					self.GenErrorMsg(self.altErr, self.curSy)
					self.codeGen.write("else:\n")
					self.codeGen.Indent(indent + 1)
					self.codeGen.write("self.SynErr(" + str(self.errorNr) + ")\n")
			elif p.typ == Node.iter:
				self.codeGen.Indent(indent)
				p2 = p.sub
				self.codeGen.write("while ")
				if p2.typ == Node.wt:
					s1 = Tab.Expected(p2.next, self.curSy)
					s2 = Tab.Expected(p.next, self.curSy)
					self.codeGen.write("self.WeakSeparator(")
					self.PrintTermName(p2.sym)
					self.codeGen.write(", " + str(self.NewCondSet(s1)) + ", " + str(self.NewCondSet(s2)) + ")")
					s1 = set()
					if p2.up or p2.next is None:
						p2 = None
					else:
						p2 = p2.next
				else:
					s1 = Tab.First(p2)
					self.GenCond(s1, p2)
				self.codeGen.write(":\n")
				self.GenCode(p2, indent + 1, s1)
				self.codeGen.write("\n")
			elif p.typ == Node.opt:
				s1 = Tab.First(p.sub)
				self.codeGen.Indent(indent)
				self.codeGen.write("if (")
				self.GenCond(s1, p.sub)
				self.codeGen.write("):\n")
				self.GenCode(p.sub, indent + 1, s1)

			if p.typ != Node.eps and p.typ != Node.sem and p.typ != Node.sync:
				for val in range(0, len(isChecked)):
					isChecked.discard(val)

			if p.up:
				break

			p = p.next

	def GenTokens(self, withNames: bool) -> None:
		assert isinstance(withNames, bool)
		for sym in Symbol.terminals:
			if sym.name[0].isalpha():
				self.codeGen.write(INDENT + "_" + sym.name + " = " + str(sym.n) + "\n")
		if withNames:
			self.codeGen.write(INDENT + "# terminals\n")
			for sym in Symbol.terminals:
				self.codeGen.write(INDENT + "" + sym.symName + " = " + str(sym.n) + "\n")
			self.codeGen.write(INDENT + "# pragmas\n")
			for sym in Symbol.pragmas:
				self.codeGen.write(INDENT + "" + sym.symName + " = " + str(sym.n) + "\n")
			self.codeGen.write("\n")

	def GenPragmas(self) -> None:
		for sym in Symbol.pragmas:
			self.codeGen.write(INDENT + "_" + str(sym.name) + " = " + str(sym.n) + "\n")

	def GenCodePragmas(self) -> None:
		for sym in Symbol.pragmas:
			self.codeGen.write("if self.la.kind == ")
			self.PrintTermName(sym)
			self.codeGen.write(":\n")
			self.codeGen.CopySourcePart(sym.semPos, 4, True)

	def GenProductions(self) -> None:
		for sym in Symbol.nonterminals:
			self.curSy = sym

			# Generate the function header
			self.codeGen.write(INDENT + "def " + sym.name + "( self")
			if sym.attrPos is not None:
				self.codeGen.write(", ")
			self.codeGen.CopySourcePart(sym.attrPos, 0)
			self.codeGen.write(" ):\n")

			# Generate the function body
			self.codeGen.CopySourcePart(sym.semPos, 2)
			self.GenCode(sym.graph, 2, set())

			# Generate the function close
			if sym.retVar is not None:
				self.codeGen.write(INDENT * 2 + "return " + sym.retVar + "\n")
			self.codeGen.write("\n")

	def InitSets(self) -> None:
		for i in range(0, len(self.symSet)):
			s = self.symSet[i]
			self.codeGen.write(INDENT * 2 + "[")
			j = 0
			for sym in Symbol.terminals:
				if sym.n in s:
					self.codeGen.write("T,")
				else:
					self.codeGen.write("x,")
				j += 1
				if j % 4 == 0:
					self.codeGen.write(" ")
			if i == (len(self.symSet) - 1):
				self.codeGen.write("x]\n")
			else:
				self.codeGen.write("x],\n")

	def __init__(self, fn: str, dir: Path) -> None:
		assert isinstance(fn, str)
		assert isinstance(dir, Path)
		self.srcName = fn
		self.srcDir = dir
		self.errorNr = -1
		self.usingPos = None

	def WriteParser(self, withNames: bool) -> None:
		assert isinstance(withNames, bool)
		assert isinstance(Tab.allSyncSets, set)
		self.symSet.append(Tab.allSyncSets)

		self.codeGen.openFiles("Parser.frame", self.srcName, "Parser.py", True)

		if withNames:
			Tab.AssignNames()

		self.err = io.StringIO()
		for sym in Symbol.terminals:
			self.GenErrorMsg(self.tErr, sym)

		self.codeGen.CopyFramePart("-->begin")
		if self.usingPos is not None:
			self.codeGen.write("\n")
			self.codeGen.CopySourcePart(self.usingPos, 0)
		self.codeGen.CopyFramePart("-->constants")
		self.GenTokens(withNames)
		self.codeGen.write(INDENT + "maxT = " + str(len(Symbol.terminals) - 1) + "\n")
		self.GenPragmas()
		self.codeGen.CopyFramePart("-->declarations")
		self.codeGen.CopySourcePart(Tab.semDeclPos, 0)
		self.codeGen.CopyFramePart("-->pragmas")
		self.GenCodePragmas()
		self.codeGen.CopyFramePart("-->productions")
		self.GenProductions()
		self.codeGen.CopyFramePart("-->parseRoot")
		self.codeGen.write(Tab.gramSy.name + "()\n")
		self.codeGen.write(INDENT * 2 + "self.Expect(")
		self.PrintTermName(Tab.eofSy)
		self.codeGen.write(")\n")
		self.codeGen.CopyFramePart("-->initialization")
		self.InitSets()
		self.codeGen.CopyFramePart("-->errors")
		self.codeGen.write(str(self.err.getvalue()))
		self.codeGen.CopyFramePart("$$$")
		self.codeGen.close()

	def WriteStatistics(self):
		Trace.WriteLine()
		Trace.WriteLine("Statistics:")
		Trace.WriteLine("-----------")
		Trace.WriteLine()
		Trace.WriteLine(str(len(Symbol.terminals)) + " terminals")
		Trace.WriteLine(str(len(Symbol.terminals) + len(Symbol.pragmas) + len(Symbol.nonterminals)) + " symbols")
		Trace.WriteLine(str(len(Node.nodes)) + " nodes")
		Trace.WriteLine(str(len(self.symSet)) + " sets")
		Trace.WriteLine()

	def PrintTermName(self, sym: Symbol) -> None:
		assert isinstance(sym, Symbol)
		assert isinstance(sym.symName, str) or (sym.symName is None)
		if sym.symName is None:
			self.codeGen.write(str(sym.n))
		else:
			self.codeGen.write("Scanner.")
			self.codeGen.write(str(sym.symName))
