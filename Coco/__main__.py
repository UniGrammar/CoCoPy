#! /usr/bin/env python
#/*-------------------------------------------------------------------------
#Coco.py -- the Compiler Driver
#Compiler Generator Coco/R,
#Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
#extended by M. Loeberbauer & A. Woess, Univ. of Linz
#ported from Java to Python by Ronald Longo
#
#This program is free software; you can redistribute it and/or modify it
#under the terms of the GNU General Public License as published by the
#Free Software Foundation; either version 2, or (at your option) any
#later version.
#
#This program is distributed in the hope that it will be useful, but
#WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
#for more details.
#
#You should have received a copy of the GNU General Public License along
#with this program; if not, write to the Free Software Foundation, Inc.,
#59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#As an exception, it is allowed to write an extension of Coco/R that is
#used as a plugin in non-free software.
#
#If not otherwise stated, any source code generated by Coco/R (other than
#Coco/R itself) does not fall under the GNU General Public License.
#-------------------------------------------------------------------------*/
#/*-------------------------------------------------------------------------
#  Trace output options
#  0 | A: prints the states of the scanner automaton
#    | C: generates a compiler driver module
#  1 | F: prints the First and Follow sets of all nonterminals
#  2 | G: prints the syntax graph of the productions
#  3 | I: traces the computation of the First sets
#  4 | J: prints the sets associated with ANYs and synchronisation sets
#  5 | M: merge error messages into compiler listing
#  6 | S: prints the symbol table (terminals, nonterminals, pragmas)
#  7 | X: prints a cross reference list of all syntax symbols
#  8 | P: prints statistics about the Coco run
#  9 | T: test grammar only
#    | N: generates names for tokens
#
#  Trace output can be switched on by the pragma
#    $ { digit | letter }
#  in the attributed grammar or as a command-line option
#  -------------------------------------------------------------------------*/
import plumbum.cli
from .CLI import CocoArgs
import sys
import os
from pathlib import Path

from .Scanner import Scanner
from .Errors import Errors
from .Trace import Trace
from .Core import DFA
from .Core import Tab
from .DriverGen import DriverGen
from .ParserGen import ParserGen
from .Parser import Parser
from .CodeGenerator import CodeGenerator

from .setupInfo import MetaData


ROOT_DIR = Path(__file__).absolute().parent


class CocoCli(CocoArgs):
	if "version" in MetaData and "author" in MetaData and "author_email" in MetaData:
		DESCRIPTION = "Coco/R v%s for Python (May 16, 2007) - Translated by %s (%s)\n" % (MetaData["version"], MetaData["author"], MetaData["author_email"])
	else:
		DESCRIPTION = "Coco/R v??? for Python (May 16, 2007) - Translated by ??? (??)\nWE CANNOT RETRIEVE THE METADATA correctly, SOMETHING GONE WRONG, FIX IT: " + repr(MetaData)

	def main(self, ATGName: plumbum.cli.ExistingFile):
		Tab.SetDDT(self)
		ATGName = Path(ATGName)
		dirName = ATGName.parent
		fileName = ATGName.name

		if not self.outputDir:
			self.outputDir = dirName

		# Setup the default frame directory
		try:
			if self.frameFileDir:
				framesDir = self.frameFileDir
			else:
				framesDir = ROOT_DIR / "frames"
			CodeGenerator.frameDir = framesDir
			Tab.frameDir = framesDir
		except BaseException:
			pass

		# Initialize the Scanner
		try:
			with ATGName.open("rt", encoding="utf-8") as s:
				try:
					strVal = s.read()
				except IOError:
					raise RuntimeError('-- Compiler Error: Failed to read from source file "%s"\n' % ATGName)
		except IOError:
			raise RuntimeError('-- Compiler Error: Cannot open file "%s"' % ATGName)

		scanner = Scanner(strVal)
		parser = Parser()

		errors = Errors(fileName, self.outputDir, Tab.ddt[5], parser.getParsingPos, parser.errorMessages)
		trace = Trace(self.outputDir)
		tab = Tab()
		dfa = DFA(fileName, dirName, self.outputDir)

		CodeGenerator.sourceDir = dirName
		CodeGenerator.frameDir = tab.frameDir
		CodeGenerator.outputDir = self.outputDir

		pg = ParserGen(fileName, dirName)
		dg = DriverGen(fileName, dirName, self.outputDir)
		parser.Parse(scanner)
		errors.Summarize(scanner.buffer)
		Trace.Close()
		if errors.count != 0:
			return 1


if __name__ == "__main__":
	CocoCli.run()
